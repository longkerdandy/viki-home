package com.github.longkerdandy.viki.home.hap.crypto;

import com.nimbusds.srp6.BigIntegerUtils;
import com.nimbusds.srp6.SRP6Routines;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;

/**
 * Secure Remote Password (SRP-6a) routines for computing the various protocol variables and
 * messages.
 *
 * This version compatible with Homekit Accessory Protocol, which generate 3072 bits private value.
 */
public class HAPSRP6Routines extends SRP6Routines {

  /**
   * Computes the server evidence message M2 = H(A | M1 | S)
   *
   * <p>Specification: Tom Wu's paper "SRP-6: Improvements and
   * refinements to the Secure Remote Password protocol", table 5, from 2002.
   *
   * @param digest The hash function 'H'. Must not be {@code null}.
   * @param A The public client value 'A'. Must not be {@code null}.
   * @param M1 The client evidence message 'M1'. Must not be {@code null}.
   * @param S The session key 'S'. Must not be {@code null}.
   * @return The resulting server evidence message 'M2'.
   */
  @Override
  public BigInteger computeServerEvidence(final MessageDigest digest,
      final BigInteger A,
      final BigInteger M1,
      final BigInteger S) {

    digest.update(BigIntegerUtils.bigIntegerToBytes(A));
    digest.update(BigIntegerUtils.bigIntegerToBytes(M1));
    digest.update(BigIntegerUtils.bigIntegerToBytes(S));

    return BigIntegerUtils.bigIntegerFromBytes(digest.digest());
  }

  /**
   * Generates a random SRP-6a client or server private value ('a' or 'b') which is in the range
   * [1,N-1] generated by a random number of at least 3072 bits.
   *
   * <p>Specification: RFC 5054.
   *
   * @param N The prime parameter 'N'. Must not be {@code null}.
   * @param random Source of randomness. Must not be {@code null}.
   * @return The resulting client or server private value ('a' or 'b').
   */
  @Override
  public BigInteger generatePrivateValue(final BigInteger N, final SecureRandom random) {
    final int minBits = Math.max(3072, N.bitLength());
    BigInteger r = BigInteger.ZERO;
    while (BigInteger.ZERO.equals(r)) {
      r = (new BigInteger(minBits, random)).mod(N);
    }
    return r;
  }
}
